#!/usr/bin/env python
r"""
Transit and ephemeris calculator
Note: eclipse times are computed without any barycentric corrections
see also https://github.com/nespinoza/exotoolbox/blob/master/exotoolbox/utils.py#L779
"""
from os import makedirs, path
import time
import datetime as dt
import argparse
from pytz import timezone as tz

# from astroquery.exoplanet_orbit_database import ExoplanetOrbitDatabase
import numpy as np
import matplotlib.pyplot as pl
from astroplan import FixedTarget, Observer, EclipsingSystem
from astroplan.plots import plot_airmass
from astroplan import (
    PrimaryEclipseConstraint,
    MoonSeparationConstraint,
    is_event_observable,
    is_always_observable,
    months_observable,
    AtNightConstraint,
    AltitudeConstraint,
    LocalTimeConstraint,
    AirmassConstraint,
)
from astropy.coordinates import SkyCoord, EarthLocation
from astropy.time import Time, TimeDelta
import astropy.units as u

from mirai import parse_target_coord, SITES, get_tois, get_ctois, plot_full_transit, get_ephem_from_nexsci, format_datetime, parse_ing_egr, parse_ing_egr_list, get_t0_per_dur
NTRANSIT=100

if __name__ == "__main__":
    arg = argparse.ArgumentParser(
        description="set-up target and observation settings"
    )
    help = (
        "target name/coord e.g. EPICx/K2x or TIC/TOIx or WASP-x or Gaia DR2x\n"
    )
    help += "or 1:12:43.2, +1:12:43 (hms, dms) or 18.18, 1.21 (deg, deg)"
    arg.add_argument("target", help=help, type=str)
    arg.add_argument("-t0", "--midtransit", help="transit midpoint [JD]", type=float)
    arg.add_argument("-per", "--period", help="orbital period [d]", type=float)
    arg.add_argument("-dur", "--duration", help="transit duration [d]", type=float)
    arg.add_argument(
        "-n",
        "--next_transit",
        help="only find next full transit",
        action="store_true",
        default=False,
    )
    # arg.add_argument('-e', '--exclude_partial_transit', help='exclude partial transit (default=False)',
    #                  action='store_true', default=False)
    # obs parameters
    arg.add_argument(
        "-d1",
        "--start_date",
        help="start date of observation [UT] e.g. 2019-02-17 (default=today)",
        type=str,
        default=None,
    )
    arg.add_argument(
        "-t1",
        "--start_time",
        help="start time of observation [UT] (default=19:00)",
        default="19:00",
        type=str,
    )
    arg.add_argument(
        "-d2",
        "--end_date",
        help="end date of observation [UT] e.g. (default=7 days later)",
        type=str,
        default=None,
    )
    arg.add_argument(
        "-t2",
        "--end_time",
        help="end time of observation [UT] (default=06:00)",
        default="06:00",
        type=str,
    )
    arg.add_argument(
        "-site",
        "--obs_site_name",
        help=f"observation site name: {list(SITES.keys())} (default OT)",
        type=str,
        default="OT",
    )
    arg.add_argument(
        "-tz", "--timezone", help="time zone", type=str, default="UTC"
    )
    # arg.add_argument('-lt', '--use_local_timezone', help='use local time zone', action='store_true', default=False)
    arg.add_argument(
        "-lat",
        "--site_lat",
        help="custom site latitude [deg]",
        type=float,
        default=None,
    )
    arg.add_argument(
        "-lon",
        "--site_lon",
        help="custom site longitude [deg]",
        type=float,
        default=None,
    )
    arg.add_argument(
        "-elev",
        "--site_elev",
        help="custom site elevation [m]",
        type=float,
        default=None,
    )
    # constraints
    arg.add_argument(
        "-alt",
        "--alt_limit",
        help="target altitude limit [deg]",
        type=float,
        default=30,
    )
    arg.add_argument(
        "-sep",
        "--min_moon_sep",
        help="moon separation limit [deg]",
        type=float,
        default=10,
    )
    # miscellaneous
    arg.add_argument(
        "-p",
        "--plot_target",
        help="plot airmass and altitude of target on first observable date",
        action="store_true",
        default=False,
    )
    arg.add_argument(
        "-s",
        "--save",
        help="save visibility plots and transit predictions in a csv file",
        action="store_true",
        default=False,
    )
    arg.add_argument(
        "-c", "--clobber", help="clobber", action="store_true", default=False
    )
    arg.add_argument(
        "-v",
        "--verbose",
        help="print details",
        action="store_true",
        default=False,
    )
    arg.add_argument(
        "--show_site_names",
        help="print accepted site_names",
        action="store_true",
        default=False,
    )
    arg.add_argument(
        "-o", "--outdir",
        help="output directory",
        type=str,
        default='target'
    )

    args = arg.parse_args()
    if args.show_site_names:
        #TODO: add this to SITES
        print(EarthLocation.get_site_names())

    else:
        target = args.target.lower().strip().replace("-", "")
        target_coord = parse_target_coord(target)
        #use target name as name of output directory
        outdir = args.outdir if args.outdir!='target' else target

        # obs params
        if args.start_date is None:
            obs_start = Time.now()
        else:
            obs_time1 = " ".join((args.start_date, args.start_time))
            obs_start = Time(obs_time1)
        if args.end_date is None:
            if args.next_transit:
                obs_end = Time.now() + TimeDelta(365, format="jd")
            else:
                obs_end = Time.now() + TimeDelta(7, format="jd")
        else:
            obs_time2 = " ".join((args.end_date, args.end_time))
            obs_end = Time(obs_time2)

        site_name = args.obs_site_name.upper()
        timezone = args.timezone

        # observatory site
        if site_name is not None:
            all_sites = list(SITES.keys())
            assert site_name in all_sites, f"-site={all_sites}"
            lat, lon, elev, timezone = SITES[site_name]
        elif (
            (lat is not None)
            & (lon is not None)
            & (elev is not None)
            & (timezone is not None)
        ):
            lat = args.site_lat
            lon = args.site_lon
            elev = args.site_elev
        else:
            # default: Observatorio del Teide
            lat, lon, elev, timezone = SITES["OT"]
        obs_site = Observer(
            latitude=lat * u.deg,
            longitude=lon * u.deg,
            elevation=elev * u.m,
            name=site_name,
            timezone=timezone,
        )

        # observation constraints
        utc_offset = tz(timezone).localize(obs_start.datetime).strftime("%z")
        time_offset = dt.timedelta(hours=int(utc_offset[1:3]))

        if args.verbose:
            print(
            f"Obs. site: {obs_site.name} ({lat}d,{lon}d,{elev}m,UTC{utc_offset})"
            )

        # 18:00 local time in UTC
        twilight_local1 = dt.datetime.combine(
            obs_start.datetime.date(), dt.time(18, 0)
        )
        twilight_utc1 = twilight_local1 - time_offset
        min_utc = twilight_utc1.time()
        # 7:00 local time in UTC
        twilight_local2 = dt.datetime.combine(
            obs_start.datetime.date(), dt.time(7, 0)
        )
        twilight_utc2 = twilight_local2 - time_offset
        max_utc = twilight_utc2.time()

        # see https://astroplan.readthedocs.io/en/latest/tutorials/constraints.html
        constraints = [
            AtNightConstraint.twilight_civil(),
            AltitudeConstraint(min=args.alt_limit * u.deg),
            LocalTimeConstraint(min=min_utc, max=max_utc),
            MoonSeparationConstraint(min=args.min_moon_sep * u.deg),
        ]
        # set-up transit parameters
        if (
            (args.midtransit is not None)
            & (args.period is not None)
            & (args.duration is not None)
        ):
            t0, per, dur = args.midtransit, args.period, args.duration
        else:
            t0, per, dur = get_t0_per_dur(target)

        primary_eclipse_time = Time(t0, format="jd")
        orbital_period = per * u.day
        transit_duration = dur * u.day

        primary_eclipse_time = Time(t0, format="jd", scale="tdb")
        system = EclipsingSystem(
            primary_eclipse_time=primary_eclipse_time,
            orbital_period=orbital_period,
            duration=transit_duration,
            name=target,
        )

        midtransit_times = system.next_primary_eclipse_time(
            obs_start, n_eclipses=NTRANSIT
        )
        midtransit_times = midtransit_times[midtransit_times < obs_end]
        # is event observable during midtransit?
        idx2 = is_event_observable(
            constraints, obs_site, target_coord, times=midtransit_times
        )[0]
        midtransit_times = midtransit_times[idx2]
        nevents_partial = sum(idx2)
        if nevents_partial > 0:
            # make sure mid-transit happens at night
            assert np.all(obs_site.is_night(midtransit_times.flatten()))
            partial = midtransit_times
        else:
            partial = []
        # is event observable during ingres and egress?
        ing_egr_times = system.next_primary_ingress_egress_time(
            obs_start, n_eclipses=NTRANSIT
        )
        ing_egr_times = ing_egr_times[ing_egr_times[:, 1] < obs_end]
        idx3 = is_event_observable(
            constraints,
            obs_site,
            target_coord,
            times_ingress_egress=ing_egr_times,
        )[0]
        ing_egr_times = ing_egr_times[idx3]
        nevents_full = sum(idx3)
        if nevents_full > 0:
            # make sure full transit happens at night
            assert np.all(obs_site.is_night(ing_egr_times.flatten()))
            if not args.next_transit:
                print(f"{target} has {nevents_full} full transits")
            full = ing_egr_times
        else:
            full = []

        d1=format_datetime(obs_start.datetime)
        d2=format_datetime(obs_end.datetime)

        if args.next_transit:
            assert  len(full)>0, f"{target} ra,deg=({target_coord.to_string()}) is likely not observable from {site_name}."
            ing_egr = full[0]
            ing, egr = ing_egr
            t14 = (egr - ing).value
            mid = ing + dt.timedelta(days=t14 / 2)
            print(f"Next full transit of {target} from {site_name} is on {mid.tdb.iso} UT.")
        else:
            print(f"{len(full)} full transit between {d1} & {d2}.")

        if args.plot_target:
            #plot only first transit
            if len(full)>0:
                print('Showing the first transit')
                fig = plot_full_transit(
                    full[0], target_coord, obs_site, name=target
                )
                pl.show()
            else:
                print('Nothing to plot.')

        if args.save:
            #save all figures
            assert  len(full)>0, f"No full transit. Nothing to save."
            if not path.exists(outdir):
                makedirs(outdir)

            for n,ing_egr in enumerate(full):
                if len(full)>1:
                    fp1 = path.join(outdir,f"{target}_{obs_site.name}_{n}.png")
                else:
                    fp1 = path.join(outdir,f"{target}_{obs_site.name}.png")
                fig = plot_full_transit(
                    ing_egr, target_coord, obs_site, name=target
                )
                fig.savefig(fp1, bbox_inches="tight")
                if args.verbose:
                    print(f"Saved: {fp1}")
            #save predictions to 1 csv file
            if args.next_transit | len(full)==1:
                #if 1 event, use transit midpoint
                ing,mid,egr = parse_ing_egr(full[0])
                d0 = format_datetime(mid.datetime)
                fp2 = path.join(outdir,f"{target}_{obs_site.name}_{d0}.csv")
            else:
                #if more, use transit query dates
                fp2 = path.join(outdir,f"{target}_{obs_site.name}_{d1}_{d2}.csv")
            np.savetxt(fp2, parse_ing_egr_list(full), delimiter=',', fmt='%s')
            if args.verbose:
                print(f"Saved: {fp2}")
